/*
Loads properties, expands them, write to project.properties

Properties will be available at definition time as
code calls run expansion (vs define an expansion task)
As usual triggered with

apply from: 'almProperties.gradle'

1. define sensible defaults for ikanHome, almHome according to os or overwrite with env/ikan alm settings
2. load additional properties from phase properties files, project property file, gradle properties file
 */

import groovy.transform.InheritConstructors
import org.gradle.internal.os.OperatingSystem

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

import static groovy.io.FileType.FILES

/*
Extends HashMap with some useful loading function
 */
@InheritConstructors
class AlmProperties extends HashMap<String, String> {

    void loadEntriesFromProperties(Properties props) {
        // Properties extends HashTable<Object,Object>
        // should force to String key and value
        for (final String name : props.stringPropertyNames())
            this.put(name, props.getProperty(name))
    }

    // putAll inherited by Map accept Properties
    // This method is used to load the properties file
    // uses a path Path rn_demo = Paths.get("C:/tutorial/Java", "demo.txt");
    boolean loadEntriesFromPropertiesFile(Path aPath) {
        InputStream iStream = null;
        boolean loaded = false
        // temp object to easy loading file
        Properties props = new Properties()
        try {
            // Loading properties file from the path (relative path given here)
            iStream = Files.newInputStream(aPath)
            props.load(iStream)
            loadEntriesFromProperties(props)
            loaded = true
        } catch (IOException e) {
            println "IOException loading ${aPath.toString()}"
        } finally {
            try {
                if (iStream != null) {
                    iStream.close();
                }
            } catch (IOException e) {
                println "IOExeception closing ${aPath.toString()}"
            }
        }
        loaded
    }

    /*
    Look for a file <project name>.properties within folder projectResources under <almSystem> and load it into AlmProperties object
    */
    Boolean loadFromAlmSystemProjectResources(String almSystem, String projectName) {
        Boolean found = false
        Path prjProps = Paths.get(almSystem, 'projectResources', projectName + '.properties')
        if (Files.isRegularFile(prjProps)) {
            if (this.loadEntriesFromPropertiesFile(prjProps)) {
                found = true
                println "Loaded ${prjProps.toString()}"
            }
        } else {
            println "Project properties file not found at ${prjProps.toString()}"
        }
        found
    }

    // look for a 'alm.package.name'.properties somewhere under source dir
    // source dir is set by IKANALM in gradle.properties
    Boolean loadFromSourcePackageProperties(String source, String pkgName) {
        Boolean found = false
        println "loadFromPackagePropertiesUnderSource source dir: $source pkgName: $pkgName"
        //def pkgNamePattern = ~/(?i)${pkgName}.properties/ case insensitive
        List<String> pkgPropList = null
        try {
            pkgPropList = new FileNameByRegexFinder().getFileNames(source, "(?i)${pkgName}.properties")
        } catch (Exception excp) {
            println "Got exception: ${excp.message}"
        }

        if (pkgPropList.size() == 1) {
            // found pkg properties file
            Path packageProps = Paths.get(pkgPropList[0])
            if (Files.exists(packageProps)) {
                this.loadEntriesFromPropertiesFile(packageProps)
                found = true
                println "Loaded ${packageProps.toString()}"
            } else {
                println "Unable to find ${packageProps.toString()}"
            }
        } else if (!pkgPropList) {
            // no pkg properties
            println "Unable to find file ${pkgName}.properties under ${source}"
        } else {
            // too many pkg properties, unable to choose
            println "Multiple files ${pkgName}.properties under ${source}, skipping..."
        }
        found
    }

    // load file *.properties under resources directory within IKANALM phase directory
    // it is a common maven standard
    def loadFromPhaseResourcesDir(File resourcesDir) {
        //eventually load resources properties - maven standard
        if (resourcesDir.exists()) {
            resourcesDir.eachFileMatch(FILES, ~/.*\.properties/) {
                File fi ->
                    if (this.loadEntriesFromPropertiesFile(fi.toPath())) {
                        println "Loaded ${fi.toPath().toString()}"
                    }
            }
        }
    }

    def dumpToFile(File fd) {
        //println('Creating all.properties file')
        if (fd.exists())
            fd.delete()
        if (fd.createNewFile()) {
            // only ext properties
            this.sort().keySet().each {
                //println "Writing ${it} ->  ${project.ext.properties[it]}"
                //project.it, project[it] etc will do
                //a single backspace would result in a interpreted char (that is \text -> \t ext) when reading back
                //so we need to double it while writing, as you can see in the original gradle properties.
                //This number of backlashes does that
                fd << "${it}=${this[it].toString().replaceAll('\\\\','\\\\\\\\')}\n"
            }
        }
    }

    Properties toProperties() {
        this as Properties
    }
}

/*
When running in a deploy environment, both alm.build.environmentName and alm.deploy.environmentName are defined
When running in a build environment, only alm.build.environmentName is defined
So we check if alm.deploy.environmentName si defined. If it is, pick that one, othewise pick alm.build.environmentName
 */
String getCurrentEnvironment() {
    // println "build has env: ${project.hasProperty('alm.build.environmentName')}"
    // println "deploy has env: ${project.hasProperty('alm.deploy.environmentName')}"
    if (project.hasProperty('alm.deploy.environmentName')) {
        project.property('alm.deploy.environmentName').toString()
    } else if (project.hasProperty('alm.build.environmentName')) {
        project.property('alm.build.environmentName').toString()
    } else {
        null
    }
}

// --- Bootstrapping ---
// set ikan.home, alm.home, alm.system path with default values
// if an env variables (IKAN_HOME, ALM_HOME) are found, use that values
// if a gradle.properties are found (dir.ikan.home, dir.alm.home) use that values
String ikanHome
println 'Configuring ' + OperatingSystem.current().getFamilyName() + ' defaults'
if (OperatingSystem.current().isLinux() || OperatingSystem.current().getFamilyName().contains('solaris')) {
    ikanHome = "/opt/ikan"
} else {
    //OperatingSystem.current().isWindows()
    ikanHome = "D:/ikan"
}

// set ikanHome
if (System.getenv('IKAN_HOME') != null) {
    ikanHome = System.getenv('IKAN_HOME').replace('\\', '/')
}
if (project.hasProperty('dir.ikan.home')) {
    ikanHome = project.property('dir.ikan.home').replace('\\', '/')
}
// set almHome
String almHome = ikanHome + '/alm'
if (System.getenv('ALM_HOME') != null) {
    almHome = System.getenv('ALM_HOME').replace('\\', '/')
}
if (project.hasProperty('dir.alm.home')) {
    almHome = project.property('dir.alm.home').replace('\\', '/')
}

String almSystem = ikanHome + '/system'
if (project.hasProperty('dir.alm.system')) {
    almSystem = project.property('dir.alm.system').replace('\\', '/')
}

// Collect properties
AlmProperties ap = new AlmProperties()
//add default properties
ap['almHome'] = almHome
ap['ikanHome'] = ikanHome
ap['almSystem'] = almSystem
ap['toolsHome'] = ikanHome + '/tools'
ap['almEnvironment'] = getCurrentEnvironment()
println "env: ${ap['almEnvironment']}"

//load <project name>.properties under system/projectResources
ap.loadFromAlmSystemProjectResources(almSystem, project.property('alm.project.name').toString())

// Package based project -> alm.package.name defined ow Release based project
// try to load package properties if package is defined and set variable to let main gradle script know
String pkgName = project.hasProperty('alm.package.name') ? project.property('alm.package.name') : null
if (pkgName) {
    Boolean foundPkgProps = ap.loadFromSourcePackageProperties(project.property('source').toString(), pkgName)
    ap['pkgPropsLoaded'] = true
} else {
    ap['pkgPropsLoaded'] = false
}

// Load properties defined at runtime from Ikan Alm and stored in gradle.properties
ap.loadEntriesFromPropertiesFile(project.file("gradle.properties").toPath())

// Now expand ${xxx} placeholder
// Dump properties to a file as ant expandproperties works on files
File uxpProps = File.createTempFile('uxp', '.properties', project.file('.'))
ap.dumpToFile(uxpProps)
File xpProps = project.file('all.properties')
// load all properties into ant to allow key/value expansion on expandproperties
ant.loadproperties(srcFile: uxpProps.canonicalPath)
ant.copy(tofile: xpProps.canonicalPath, file: uxpProps.canonicalPath, overwrite: true) {
    filterchain() {
        expandproperties()
    }
}
Files.delete(uxpProps.toPath())
// load again expanded properties and then move loaded properties into to (gradle) project.ext
// Properties will then be available to gradle at configuration and execution time
AlmProperties allp = new AlmProperties()
allp.loadEntriesFromPropertiesFile(xpProps.toPath())
allp.keySet().each {
    project.ext[it] = allp[it]
}
